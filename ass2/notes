

General Approach:

Both servers start identically during setup phase, and both have a similarly structured listen loop.

For each client connection:
    - Threaded server spawns a thread.
        - no need to `join` later, so `detached` for automatic resource cleanup
    - Forked server forks a child process
        - child processes inherit socket fd, so no IPC required

Both servers handle clients with the exact same function, though the threaded server's handler is wrapped to receive arguments in `void *` form.


Client Handler:

1. Takes a single accepted socket and reads the sent data.
2. Attempts to validate the request format by parsing it into a struct
3. Checks if requested file exists with a stat call
4. Constructs response with pointer/length pair
    1. Checks file length with stat call
       http://stackoverflow.com/questions/8236/how-do-you-determine-the-size-of-a-file-in-c
    2. Constructs header string (can be on stack - small)
    3. Mallocs string with enough room for header, file, and null
    4. Copies header onto malloced thing
    5. Reads the file onto end of malloced thing
5. Writes response from pointer/length pair
6. Frees malloced string
7. Closes socket


Notes:

- how do i daemonize within my code?

- are there necessary cleanup steps for threads or processes?

- is there a single file write sync architecture I can use for fork() and pthreads?
    yep. mutex.  note special initialization process for fork() mutexing at
        http://stackoverflow.com/questions/6847973/do-forked-child-processes-use-the-same-semaphore
    and in the corresponding code in
        /lab/mutex/forky.c
